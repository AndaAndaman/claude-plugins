---
name: Directory Summarization
description: Use this skill when analyzing directories to generate CLAUDE.md context files, or when you need guidance on documenting module structure, file purposes, patterns, and dependencies in a concise format.
version: 1.0.0
---

# Directory Summarization

Generate concise, high-quality CLAUDE.md context files for subdirectories in codebases to preserve module knowledge between sessions.

## Purpose

When Claude works through a codebase, understanding of what each module does can be lost between sessions. This skill provides methodology for creating subdirectory CLAUDE.md files that act as "knowledge breadcrumbs" - loaded automatically when Claude reads files in that directory.

## When to Use This Skill

- Generating CLAUDE.md files for modules/directories
- Documenting module purpose, structure, and conventions
- Analyzing file relationships and dependencies
- Detecting architectural and design patterns in code
- Creating concise summaries that help future sessions understand code quickly

## CLAUDE.md Template

Use this standard structure for all generated context files:

```markdown
<!-- AUTO-GENERATED by local-memory plugin on YYYY-MM-DD -->
<!-- To preserve custom content, add sections outside auto-gen blocks -->

# Module: [Directory Name]

## Overview
[2-3 sentences describing module purpose and role]

## Files

### filename.ext
[1-2 sentence description of what file does and key exports]

### another-file.ext
[1-2 sentence description]

## Key Patterns & Conventions

- [Observable pattern 1]
- [Observable pattern 2]
- [Design decisions and conventions]

## Dependencies

**Internal Dependencies:**
- `./relative/path` - [Why needed, what it provides]

**External Dependencies:**
- `package-name` - [How used in this module]

**Used By:**
- `../consuming/module` - [How this module is consumed]

<!-- END AUTO-GENERATED CONTENT -->
```

## Overview Section

The overview should answer:
- What is the primary purpose of this module/directory?
- What role does it play in the larger system?
- What problem does it solve?

**Good overview examples:**
```
REST API endpoints for user management. Handles authentication,
user CRUD operations, and profile updates. Serves as the HTTP
interface layer between frontend clients and business logic services.
```

```
Shared utility functions for data validation and transformation.
Provides pure functions used across the application for common
operations like date formatting, string manipulation, and type checking.
```

**Bad overview examples:**
```
This directory contains files for the API.
```
(Too vague, doesn't explain purpose or role)

```
The UserController class extends BaseController and implements the
IUserOperations interface. It uses dependency injection to receive
the UserService and ValidationMiddleware instances...
```
(Too implementation-focused, should focus on "what" not "how")

## File Summaries

Keep file descriptions to 1-2 sentences. Focus on:
- Primary responsibility of the file
- Key exports (classes, functions, types)
- How it fits into the module

**Template**: `[What it does] + [Key exports/features]`

**Good file summary examples:**

```markdown
### UserController.ts
Handles HTTP requests for user operations (create, read, update, delete).
Exports UserController class with route handlers.
```

```markdown
### validation.ts
Provides input validation utilities for user data. Exports validateEmail,
validatePassword, and validateUserProfile functions.
```

```markdown
### types.ts
TypeScript type definitions for user entities. Exports User, UserProfile,
and UserCredentials interfaces.
```

**Bad file summary examples:**

```markdown
### UserController.ts
This file contains the UserController class.
```
(Doesn't explain what it does)

```markdown
### validation.ts
Validation functions including validateEmail which uses regex pattern
/^[^\s@]+@[^\s@]+\.[^\s@]+$/ to check email format, validatePassword
which checks length >= 8 and requires one uppercase, one number...
```
(Too detailed, implementation belongs in code not documentation)

## Pattern Detection

Identify and document observable patterns in the code. Categories:

### Naming Conventions
- Case style: camelCase, PascalCase, snake_case, SCREAMING_SNAKE_CASE
- Prefixes/suffixes: `_private`, `I` for interfaces, `Base` for abstract classes
- File naming: kebab-case, PascalCase for classes, index files

**Examples:**
```
- Naming: PascalCase for classes, camelCase for functions and variables
- Private fields: Prefixed with underscore (_fieldName)
- Test files: Named as [filename].spec.ts
```

### Architectural Patterns
- Layered architecture (Controller → Service → Repository)
- MVC (Model-View-Controller)
- Clean Architecture / Hexagonal Architecture
- Microservices patterns
- Domain-Driven Design (bounded contexts, aggregates)

**Examples:**
```
- Architecture: Layered - Controllers handle HTTP, Services contain
  business logic, Repositories manage data access
- DDD: Each subdirectory is a bounded context with its own entities
```

### Framework-Specific Patterns
- React: Functional components, hooks, context
- Angular: Services, modules, dependency injection
- Express: Middleware chains, route handlers
- .NET: Controllers, services, async/await

**Examples:**
```
- React: Functional components using hooks (useState, useEffect)
- Angular: Services use singleton pattern via providedIn: 'root'
```

### Design Patterns
- Factory, Builder, Strategy, Observer, Decorator, etc.
- When detected, note where and why they're used

**Examples:**
```
- Factory pattern: UserFactory creates user instances with validation
- Strategy pattern: Different authentication strategies (JWT, OAuth, API key)
```

### Error Handling
- Try-catch usage
- Error propagation strategy
- Custom error types

**Examples:**
```
- Error handling: Custom error classes extend Error, thrown up to
  controller middleware
```

## Dependency Analysis

Map three types of dependencies using import/export analysis:

### Internal Dependencies
Files within this directory that depend on each other.

**How to detect**: Use Grep for `import.*from ['"]\.\/` to find relative imports

**Format:**
```
- `./auth-service` - Provides authentication checking for route handlers
- `./validation` - Used by all controllers for input validation
```

### External Dependencies
Packages and modules from outside this directory.

**How to detect**: Use Grep for `import.*from ['"][^.]` to find package imports

**Categories:**
- Framework (e.g., express, react, angular)
- Utilities (e.g., lodash, date-fns)
- Business logic from other modules (e.g., ../services/user)

**Format:**
```
- `express` - HTTP server and routing
- `lodash` - Utility functions for data manipulation
- `../services/user-service` - Business logic for user operations
```

### Used By (Consumers)
Other parts of the codebase that import from this directory.

**How to detect**: Use Grep in parent directories for imports pointing to current directory

**Format:**
```
- `../api/routes` - Imports controllers for route handlers
- `../frontend/services` - Consumes API client functions
```

## Smart Merging Strategy

When updating existing CLAUDE.md files, preserve user content:

### Detection
1. Read existing CLAUDE.md file
2. Look for markers:
   - `<!-- AUTO-GENERATED -->` ... `<!-- END AUTO-GENERATED -->`
   - `<!-- USER CONTENT -->`
   - Custom sections outside auto-gen blocks

### Preservation
- **Keep**: Everything outside auto-generated blocks
- **Update**: Content between AUTO-GENERATED markers
- **Append**: User sections at the end if present

### Implementation
```
1. Read existing file
2. Extract user content (everything outside <!-- AUTO-GENERATED -->)
3. Generate new auto-generated sections
4. Combine: new auto-gen + preserved user content
5. Use Edit tool for surgical updates or Write for complete regeneration
```

## Conciseness Guidelines

Target 200-400 lines, maximum 500 lines per CLAUDE.md.

### Techniques for Staying Concise

**1. One-line file summaries when appropriate:**
```markdown
### config.ts
Application configuration constants and environment variables.
```

**2. Group similar files:**
```markdown
### handler files (create-user.ts, update-user.ts, delete-user.ts)
Individual route handlers for user CRUD operations. Each exports a single
async handler function.
```

**3. Summarize patterns instead of listing every instance:**
```markdown
## Key Patterns & Conventions

- Handlers: Each handler is a separate file exporting one async function
- Validation: All handlers use validate() middleware before business logic
```

**4. Reference instead of repeating:**
```markdown
### tests/ (5 spec files)
Unit tests for all handler functions. See individual spec files for test cases.
```

**5. Limit dependency detail:**
```markdown
**External Dependencies:**
- `express`, `body-parser`, `cors` - Standard Express setup
- `joi` - Request validation
```

## File Priority for Analysis

When maxFilesAnalyzed limit is reached, prioritize:

1. **Entry points**: index.ts, main.ts, app.ts
2. **Exports**: Files that export primary interfaces
3. **Controllers/Handlers**: User-facing logic
4. **Core logic**: Services, business logic
5. **Types/Interfaces**: Type definitions
6. **Utilities**: Helper functions
7. **Tests**: Test files (lower priority)

Note in CLAUDE.md: "Analysis covers N primary files. Additional X files not detailed."

## Quality Checklist

Before finalizing CLAUDE.md, verify:

- [ ] Overview clearly states module purpose
- [ ] Each file has 1-2 sentence summary
- [ ] Patterns section documents observable conventions
- [ ] Dependencies section maps relationships
- [ ] Total length under 500 lines
- [ ] No implementation details (focus on "what" not "how")
- [ ] User content preserved if updating existing file
- [ ] Auto-generated markers present
- [ ] Consistent markdown formatting

## Examples

See `examples/` directory for complete CLAUDE.md samples:
- `good-context-example.md` - Well-structured, concise documentation showing proper module overview, file summaries, patterns, and dependencies
- `bad-context-example.md` - Common mistakes to avoid with explanations of why they're problematic

## Utilities

Use `scripts/analyze-directory.sh` for automated pattern detection:
```bash
bash "${CLAUDE_PLUGIN_ROOT}/skills/directory-summarization/scripts/analyze-directory.sh" <directory>
```

Returns JSON with detected patterns, file types, and import graph.

## References

For deeper guidance, see:
- `references/pattern-catalog.md` - Complete list of detectable patterns (480 lines covering naming, architecture, frameworks, design patterns)
