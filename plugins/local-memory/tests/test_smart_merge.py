"""Tests for write_context smart merge behavior.

Scenarios tested:
1. New file (no existing CLAUDE.md) - creates with update log
2. Existing file WITH auto-gen markers - replaces auto-gen block, preserves user content
3. Existing file WITHOUT markers (general CLAUDE.md) - preserves all content above new block
4. Update history accumulates across multiple writes
5. Same-day updates don't duplicate dates
"""

import asyncio
import json
import os
import re
import sys
import tempfile
import shutil

# Add parent dirs to path so we can import the server module
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', 'server'))
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))

from context_builder import handle_call_tool, _OPEN_MARKER_RE, _CLOSE_MARKER_RE, _UPDATES_RE


def run(coro):
    """Helper to run async functions."""
    return asyncio.get_event_loop().run_until_complete(coro)


class TestSmartMerge:
    """Test suite for write_context smart merge."""

    def setup_method(self):
        """Create a temp directory for each test."""
        self.tmpdir = tempfile.mkdtemp(prefix="local-memory-test-")
        self.test_dir = os.path.join(self.tmpdir, "test-module")
        os.makedirs(self.test_dir)
        self.claude_md = os.path.join(self.test_dir, "CLAUDE.md")

    def teardown_method(self):
        """Clean up temp directory."""
        shutil.rmtree(self.tmpdir, ignore_errors=True)

    def _write_context(self, content, smart_merge=True):
        """Helper to call write_context tool."""
        result = run(handle_call_tool("write_context", {
            "directory": self.test_dir,
            "content": content,
            "smart_merge": smart_merge,
            "project_root": self.tmpdir,
        }))
        return json.loads(result[0].text)

    def _read_claude_md(self):
        with open(self.claude_md, 'r', encoding='utf-8') as f:
            return f.read()

    # ----------------------------------------------------------------
    # Scenario 1: Brand new file
    # ----------------------------------------------------------------
    def test_new_file_created_with_markers_and_update_log(self):
        """New CLAUDE.md should have markers and an Updates comment."""
        result = self._write_context("# Module: Test\n\nThis is auto-generated content about the module.")

        assert result["success"] is True
        assert result["action"] == "created"

        content = self._read_claude_md()
        assert "<!-- AUTO-GENERATED by local-memory plugin" in content
        assert "<!-- END AUTO-GENERATED CONTENT -->" in content

        # Should have Updates comment
        updates_match = _UPDATES_RE.search(content)
        assert updates_match is not None, "Missing <!-- Updates: ... --> comment"
        dates = updates_match.group(1).split(",")
        assert len(dates) >= 1, "Should have at least today's date"
        print(f"  PASS: New file has update log: {updates_match.group(0)}")

    # ----------------------------------------------------------------
    # Scenario 2: Existing file WITH markers - merge preserves user content
    # ----------------------------------------------------------------
    def test_existing_with_markers_preserves_user_content(self):
        """User content outside markers must survive an update."""
        # Write initial file with user content above and below
        initial = """# My Custom Notes

These are manually written notes that must be preserved.

<!-- AUTO-GENERATED by local-memory plugin on 2026-02-10 -->
<!-- Updates: 2026-02-10 -->
<!-- To preserve custom content, add sections outside auto-gen blocks -->

# Module: Test

## Overview

Old auto-generated overview that should be REPLACED.

<!-- END AUTO-GENERATED CONTENT -->

## My Custom Section Below

This content below the markers must also be preserved.
"""
        with open(self.claude_md, 'w', encoding='utf-8') as f:
            f.write(initial)

        # Now trigger a new write_context
        result = self._write_context("# Module: Test\n\n## Overview\n\nNEW auto-generated content replacing old.")

        assert result["success"] is True
        assert result["action"] == "updated"

        content = self._read_claude_md()

        # User content ABOVE markers preserved
        assert "# My Custom Notes" in content
        assert "manually written notes that must be preserved" in content

        # User content BELOW markers preserved
        assert "## My Custom Section Below" in content
        assert "content below the markers must also be preserved" in content

        # Old auto-gen content REPLACED
        assert "Old auto-generated overview that should be REPLACED" not in content
        assert "NEW auto-generated content replacing old" in content

        # Update history accumulated
        updates_match = _UPDATES_RE.search(content)
        assert updates_match is not None
        dates_str = updates_match.group(1)
        assert "2026-02-10" in dates_str, "Previous date should be preserved in history"
        print(f"  PASS: Merged with markers. Updates: {dates_str}")

    # ----------------------------------------------------------------
    # Scenario 3: Existing file WITHOUT markers (general/manual CLAUDE.md)
    # ----------------------------------------------------------------
    def test_existing_without_markers_preserves_all_content(self):
        """A manually-written CLAUDE.md with NO markers must be fully preserved."""
        manual_content = """# Project Guidelines

## Architecture

This project uses Clean Architecture with the following layers:
- Controllers
- Facades
- Logic
- Services
- DataHandlers

## Naming Conventions

- Use _underscore prefix for private fields
- Use flowaccount component prefix

## Important Notes

DO NOT delete this content. It was carefully written by the team.
"""
        with open(self.claude_md, 'w', encoding='utf-8') as f:
            f.write(manual_content)

        # Trigger auto-gen write
        result = self._write_context("# Module: Project\n\n## Overview\n\nAuto-generated module overview.")

        assert result["success"] is True
        assert result["action"] == "updated"
        # Should warn about no markers
        assert any("no auto-generated markers" in w.lower() for w in result.get("warnings", []))

        content = self._read_claude_md()

        # ALL original content preserved
        assert "# Project Guidelines" in content
        assert "Clean Architecture" in content
        assert "_underscore prefix for private fields" in content
        assert "DO NOT delete this content" in content

        # New auto-gen block added AFTER the preserved content
        assert "<!-- AUTO-GENERATED" in content
        assert "Auto-generated module overview" in content
        assert "<!-- END AUTO-GENERATED CONTENT -->" in content

        # Verify order: user content comes BEFORE auto-gen block
        user_pos = content.index("# Project Guidelines")
        autogen_pos = content.index("<!-- AUTO-GENERATED")
        assert user_pos < autogen_pos, "User content should appear before auto-generated block"
        print(f"  PASS: Marker-less file preserved. User content at {user_pos}, auto-gen at {autogen_pos}")

    # ----------------------------------------------------------------
    # Scenario 4: Update history accumulates across multiple writes
    # ----------------------------------------------------------------
    def test_update_history_accumulates(self):
        """Multiple writes should accumulate dates in the Updates comment."""
        # Simulate a file written on 2026-02-08 with history
        initial = """<!-- AUTO-GENERATED by local-memory plugin on 2026-02-10 -->
<!-- Updates: 2026-02-10, 2026-02-09, 2026-02-08 -->
<!-- To preserve custom content, add sections outside auto-gen blocks -->

# Module: Test

Old content.

<!-- END AUTO-GENERATED CONTENT -->
"""
        with open(self.claude_md, 'w', encoding='utf-8') as f:
            f.write(initial)

        result = self._write_context("# Module: Test\n\nUpdated content.")
        assert result["success"] is True

        content = self._read_claude_md()
        updates_match = _UPDATES_RE.search(content)
        assert updates_match is not None

        dates = [d.strip() for d in updates_match.group(1).split(",")]
        # Today should be first, then previous dates in order
        from datetime import datetime
        today = datetime.now().strftime('%Y-%m-%d')
        assert dates[0] == today, f"First date should be today ({today}), got {dates[0]}"

        # Previous dates preserved
        assert "2026-02-10" in dates
        assert "2026-02-09" in dates
        assert "2026-02-08" in dates
        print(f"  PASS: History accumulated: {', '.join(dates)}")

    # ----------------------------------------------------------------
    # Scenario 5: Same-day update doesn't duplicate
    # ----------------------------------------------------------------
    def test_same_day_no_duplicate(self):
        """Writing twice on the same day should not duplicate the date."""
        from datetime import datetime
        today = datetime.now().strftime('%Y-%m-%d')

        initial = f"""<!-- AUTO-GENERATED by local-memory plugin on {today} -->
<!-- Updates: {today} -->

# Module: Test

Content.

<!-- END AUTO-GENERATED CONTENT -->
"""
        with open(self.claude_md, 'w', encoding='utf-8') as f:
            f.write(initial)

        result = self._write_context("# Module: Test\n\nNew content same day.")
        assert result["success"] is True

        content = self._read_claude_md()
        updates_match = _UPDATES_RE.search(content)
        assert updates_match is not None

        dates = [d.strip() for d in updates_match.group(1).split(",")]
        # Should have today only once
        assert dates.count(today) == 1, f"Today ({today}) should appear exactly once, got {dates.count(today)}"
        print(f"  PASS: No duplicate on same day: {', '.join(dates)}")

    # ----------------------------------------------------------------
    # Scenario 6: Creation date preserved on update
    # ----------------------------------------------------------------
    def test_creation_date_preserved_on_update(self):
        """The opening marker should keep the original creation date, not today's date."""
        initial = """<!-- AUTO-GENERATED by local-memory plugin on 2026-02-08 -->
<!-- Updates: 2026-02-08 -->
<!-- To preserve custom content, add sections outside auto-gen blocks -->

# Module: Test

Original content.

<!-- END AUTO-GENERATED CONTENT -->
"""
        with open(self.claude_md, 'w', encoding='utf-8') as f:
            f.write(initial)

        result = self._write_context("# Module: Test\n\nUpdated content on a later day.")
        assert result["success"] is True

        content = self._read_claude_md()

        # Opening marker must show ORIGINAL creation date, not today
        open_match = _OPEN_MARKER_RE.search(content)
        assert open_match is not None
        marker_date = re.search(r'on (\d{4}-\d{2}-\d{2})', open_match.group())
        assert marker_date is not None
        assert marker_date.group(1) == "2026-02-08", \
            f"Creation date should be 2026-02-08, got {marker_date.group(1)}"

        # Updates should contain today as most recent
        updates_match = _UPDATES_RE.search(content)
        assert updates_match is not None
        dates = [d.strip() for d in updates_match.group(1).split(",")]
        from datetime import datetime
        today = datetime.now().strftime('%Y-%m-%d')
        assert dates[0] == today, f"First update should be today ({today}), got {dates[0]}"
        assert "2026-02-08" in dates, "Original date should be in update history"
        print(f"  PASS: Creation date preserved: {open_match.group()}, Updates: {', '.join(dates)}")


def main():
    """Run all tests manually."""
    test = TestSmartMerge()
    tests = [
        ("1. New file with markers and update log", test.test_new_file_created_with_markers_and_update_log),
        ("2. Existing with markers preserves user content", test.test_existing_with_markers_preserves_user_content),
        ("3. Existing WITHOUT markers preserves all content", test.test_existing_without_markers_preserves_all_content),
        ("4. Update history accumulates", test.test_update_history_accumulates),
        ("5. Same-day no duplicate", test.test_same_day_no_duplicate),
        ("6. Creation date preserved on update", test.test_creation_date_preserved_on_update),
    ]

    passed = 0
    failed = 0
    for name, fn in tests:
        test.setup_method()
        try:
            fn()
            print(f"  OK: {name}")
            passed += 1
        except Exception as e:
            print(f"  FAIL: {name}")
            print(f"    Error: {e}")
            import traceback
            traceback.print_exc()
            failed += 1
        finally:
            test.teardown_method()

    print(f"\n{'='*50}")
    print(f"Results: {passed} passed, {failed} failed out of {passed + failed}")
    if failed == 0:
        print("All tests PASSED!")
    else:
        print("Some tests FAILED!")
        sys.exit(1)


if __name__ == "__main__":
    main()
