"""Tests for Timeline section in write_context.

Scenarios tested:
1. New file gets initial timeline entry
2. Updates accumulate timeline entries
3. Same-day updates replace description
4. Max 20 entry cap
5. Backward compat - existing file without timeline
6. No change_description -> "Content updated" fallback
7. Timeline placement inside auto-gen block
8. User content preserved with timeline present
"""

import asyncio
import json
import os
import re
import sys
import tempfile
import shutil

# Add parent dirs to path so we can import the server module
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', 'server'))
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))

from context_builder import (
    handle_call_tool,
    _OPEN_MARKER_RE,
    _CLOSE_MARKER_RE,
    _TIMELINE_SECTION_RE,
    _TIMELINE_ENTRY_RE,
    _TIMELINE_MAX_ENTRIES,
    _parse_timeline,
    _build_timeline_section,
)
from datetime import datetime


def run(coro):
    """Helper to run async functions."""
    return asyncio.get_event_loop().run_until_complete(coro)


class TestTimeline:
    """Test suite for Timeline section in write_context."""

    def setup_method(self):
        """Create a temp directory for each test."""
        self.tmpdir = tempfile.mkdtemp(prefix="local-memory-timeline-test-")
        self.test_dir = os.path.join(self.tmpdir, "test-module")
        os.makedirs(self.test_dir)
        self.claude_md = os.path.join(self.test_dir, "CLAUDE.md")
        self.today = datetime.now().strftime('%Y-%m-%d')

    def teardown_method(self):
        """Clean up temp directory."""
        shutil.rmtree(self.tmpdir, ignore_errors=True)

    def _write_context(self, content, smart_merge=True, change_description=None):
        """Helper to call write_context tool."""
        args = {
            "directory": self.test_dir,
            "content": content,
            "smart_merge": smart_merge,
            "project_root": self.tmpdir,
        }
        if change_description is not None:
            args["change_description"] = change_description
        result = run(handle_call_tool("write_context", args))
        return json.loads(result[0].text)

    def _read_claude_md(self):
        with open(self.claude_md, 'r', encoding='utf-8') as f:
            return f.read()

    # ----------------------------------------------------------------
    # T1: New file gets initial timeline entry
    # ----------------------------------------------------------------
    def test_new_file_gets_timeline(self):
        """A new CLAUDE.md should have a Timeline section with one entry."""
        result = self._write_context(
            "# Module: Test\n\nThis is auto-generated content about the module.",
            change_description="Initial context generation"
        )
        assert result["success"] is True
        assert result["action"] == "created"

        content = self._read_claude_md()
        entries = _parse_timeline(content)
        assert len(entries) == 1, f"Expected 1 timeline entry, got {len(entries)}"
        assert entries[0]["date"] == self.today
        assert entries[0]["description"] == "Initial context generation"
        print(f"  PASS: New file has timeline entry: {entries[0]}")

    # ----------------------------------------------------------------
    # T2: Updates accumulate timeline entries
    # ----------------------------------------------------------------
    def test_updates_accumulate_entries(self):
        """Multiple writes on different days should accumulate timeline entries."""
        initial = f"""<!-- AUTO-GENERATED by local-memory plugin on 2026-02-10 -->
<!-- Updates: 2026-02-10 -->

# Module: Test

Old content.

## Timeline
- **2026-02-10** — Initial generation
- **2026-02-09** — First draft

<!-- END AUTO-GENERATED CONTENT -->
"""
        with open(self.claude_md, 'w', encoding='utf-8') as f:
            f.write(initial)

        result = self._write_context(
            "# Module: Test\n\nUpdated content.",
            change_description="Added new utilities"
        )
        assert result["success"] is True

        content = self._read_claude_md()
        entries = _parse_timeline(content)
        assert len(entries) == 3, f"Expected 3 timeline entries, got {len(entries)}"
        assert entries[0]["date"] == self.today
        assert entries[0]["description"] == "Added new utilities"
        assert entries[1]["date"] == "2026-02-10"
        assert entries[2]["date"] == "2026-02-09"
        print(f"  PASS: Accumulated {len(entries)} timeline entries")

    # ----------------------------------------------------------------
    # T3: Same-day updates replace description
    # ----------------------------------------------------------------
    def test_same_day_replaces_description(self):
        """Writing twice on the same day should replace the existing entry's description."""
        initial = f"""<!-- AUTO-GENERATED by local-memory plugin on {self.today} -->
<!-- Updates: {self.today} -->

# Module: Test

Content.

## Timeline
- **{self.today}** — Old description from earlier today
- **2026-02-10** — Previous day entry

<!-- END AUTO-GENERATED CONTENT -->
"""
        with open(self.claude_md, 'w', encoding='utf-8') as f:
            f.write(initial)

        result = self._write_context(
            "# Module: Test\n\nNew content same day.",
            change_description="New description replacing old"
        )
        assert result["success"] is True

        content = self._read_claude_md()
        entries = _parse_timeline(content)
        # Should have 2 entries: today (replaced) + previous day
        today_entries = [e for e in entries if e["date"] == self.today]
        assert len(today_entries) == 1, f"Expected exactly 1 today entry, got {len(today_entries)}"
        assert today_entries[0]["description"] == "New description replacing old"
        assert len(entries) == 2
        print(f"  PASS: Same-day entry replaced: {today_entries[0]}")

    # ----------------------------------------------------------------
    # T4: Max 20 entry cap
    # ----------------------------------------------------------------
    def test_max_entry_cap(self):
        """Timeline should cap at 20 entries, dropping oldest."""
        # Build 22 existing entries
        entry_lines = []
        for i in range(22):
            day = f"2026-01-{22 - i:02d}"
            entry_lines.append(f"- **{day}** — Entry number {22 - i}")

        initial = f"""<!-- AUTO-GENERATED by local-memory plugin on 2026-01-22 -->
<!-- Updates: 2026-01-22 -->

# Module: Test

Content.

## Timeline
{chr(10).join(entry_lines)}

<!-- END AUTO-GENERATED CONTENT -->
"""
        with open(self.claude_md, 'w', encoding='utf-8') as f:
            f.write(initial)

        result = self._write_context(
            "# Module: Test\n\nNew content.",
            change_description="Latest update"
        )
        assert result["success"] is True

        content = self._read_claude_md()
        entries = _parse_timeline(content)
        assert len(entries) == _TIMELINE_MAX_ENTRIES, \
            f"Expected {_TIMELINE_MAX_ENTRIES} entries, got {len(entries)}"
        assert entries[0]["date"] == self.today
        assert entries[0]["description"] == "Latest update"
        print(f"  PASS: Capped at {len(entries)} entries (max={_TIMELINE_MAX_ENTRIES})")

    # ----------------------------------------------------------------
    # T5: Backward compat - existing file without timeline
    # ----------------------------------------------------------------
    def test_backward_compat_no_existing_timeline(self):
        """Existing file without Timeline section should get one added."""
        initial = """<!-- AUTO-GENERATED by local-memory plugin on 2026-02-10 -->
<!-- Updates: 2026-02-10 -->
<!-- To preserve custom content, add sections outside auto-gen blocks -->

# Module: Test

## Overview

Old content without any timeline section.

<!-- END AUTO-GENERATED CONTENT -->
"""
        with open(self.claude_md, 'w', encoding='utf-8') as f:
            f.write(initial)

        result = self._write_context(
            "# Module: Test\n\n## Overview\n\nUpdated overview.",
            change_description="Updated module overview"
        )
        assert result["success"] is True

        content = self._read_claude_md()
        entries = _parse_timeline(content)
        assert len(entries) == 1, f"Expected 1 timeline entry, got {len(entries)}"
        assert entries[0]["date"] == self.today
        assert entries[0]["description"] == "Updated module overview"
        # Updates comment should still be present (backward compat)
        assert "<!-- Updates:" in content
        print(f"  PASS: Timeline added to file that had none")

    # ----------------------------------------------------------------
    # T6: No change_description -> "Content updated" fallback
    # ----------------------------------------------------------------
    def test_fallback_description(self):
        """When no change_description is provided, use 'Content updated'."""
        result = self._write_context(
            "# Module: Test\n\nThis is auto-generated content about the module."
        )
        assert result["success"] is True

        content = self._read_claude_md()
        entries = _parse_timeline(content)
        assert len(entries) == 1
        assert entries[0]["description"] == "Content updated"
        print(f"  PASS: Fallback description used: '{entries[0]['description']}'")

    # ----------------------------------------------------------------
    # T7: Timeline placement inside auto-gen block
    # ----------------------------------------------------------------
    def test_timeline_inside_autogen_block(self):
        """Timeline must appear inside auto-gen markers, before closing marker."""
        result = self._write_context(
            "# Module: Test\n\nContent here.",
            change_description="Test placement"
        )
        assert result["success"] is True

        content = self._read_claude_md()
        open_pos = content.index("<!-- AUTO-GENERATED")
        close_pos = content.index("<!-- END AUTO-GENERATED CONTENT -->")
        timeline_pos = content.index("## Timeline")

        assert open_pos < timeline_pos < close_pos, \
            f"Timeline ({timeline_pos}) must be between open ({open_pos}) and close ({close_pos}) markers"

        # Verify the entry is there
        entry_match = _TIMELINE_ENTRY_RE.search(content)
        assert entry_match is not None
        assert entry_match.group(2) == "Test placement"
        print(f"  PASS: Timeline at pos {timeline_pos}, between markers at {open_pos} and {close_pos}")

    # ----------------------------------------------------------------
    # T8: User content preserved with timeline present
    # ----------------------------------------------------------------
    def test_user_content_preserved_with_timeline(self):
        """User content above and below markers must survive with timeline present."""
        initial = f"""# My Custom Notes

Important user notes.

<!-- AUTO-GENERATED by local-memory plugin on 2026-02-10 -->
<!-- Updates: 2026-02-10 -->

# Module: Test

Old auto content.

## Timeline
- **2026-02-10** — Previous update

<!-- END AUTO-GENERATED CONTENT -->

## My Section Below

User content below markers.
"""
        with open(self.claude_md, 'w', encoding='utf-8') as f:
            f.write(initial)

        result = self._write_context(
            "# Module: Test\n\n## Overview\n\nNew auto content.",
            change_description="Refreshed module docs"
        )
        assert result["success"] is True

        content = self._read_claude_md()

        # User content preserved
        assert "# My Custom Notes" in content
        assert "Important user notes" in content
        assert "## My Section Below" in content
        assert "User content below markers" in content

        # Old auto content replaced
        assert "Old auto content" not in content
        assert "New auto content" in content

        # Timeline accumulated
        entries = _parse_timeline(content)
        assert len(entries) == 2
        assert entries[0]["date"] == self.today
        assert entries[0]["description"] == "Refreshed module docs"
        assert entries[1]["date"] == "2026-02-10"
        print(f"  PASS: User content preserved, timeline has {len(entries)} entries")


def main():
    """Run all tests manually."""
    test = TestTimeline()
    tests = [
        ("T1. New file gets initial timeline entry", test.test_new_file_gets_timeline),
        ("T2. Updates accumulate timeline entries", test.test_updates_accumulate_entries),
        ("T3. Same-day updates replace description", test.test_same_day_replaces_description),
        ("T4. Max 20 entry cap", test.test_max_entry_cap),
        ("T5. Backward compat - no existing timeline", test.test_backward_compat_no_existing_timeline),
        ("T6. No change_description fallback", test.test_fallback_description),
        ("T7. Timeline placement inside auto-gen block", test.test_timeline_inside_autogen_block),
        ("T8. User content preserved with timeline", test.test_user_content_preserved_with_timeline),
    ]

    passed = 0
    failed = 0
    for name, fn in tests:
        test.setup_method()
        try:
            fn()
            print(f"  OK: {name}")
            passed += 1
        except Exception as e:
            print(f"  FAIL: {name}")
            print(f"    Error: {e}")
            import traceback
            traceback.print_exc()
            failed += 1
        finally:
            test.teardown_method()

    print(f"\n{'='*50}")
    print(f"Results: {passed} passed, {failed} failed out of {passed + failed}")
    if failed == 0:
        print("All tests PASSED!")
    else:
        print("Some tests FAILED!")
        sys.exit(1)


if __name__ == "__main__":
    main()
